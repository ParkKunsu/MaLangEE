<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MaLangEE Realtime Test</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            text-align: center;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
        }

        #status {
            margin-top: 20px;
            font-weight: bold;
            color: gray;
        }

        #log {
            margin-top: 20px;
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
        }
    </style>
</head>

<body>
    <h1>MaLangEE Realtime w/ Debug</h1>

    <!-- 1. Session Control -->
    <div style="margin-bottom: 20px;">
        <label>Session ID: </label>
        <input type="text" id="sessionIdInput" placeholder="Leave empty for auto-gen"
            style="width: 300px; padding: 5px;">
        <button onclick="generateUUID()">ðŸŽ² Generate New</button>
    </div>

    <button id="connectBtn">Connect & Start</button>
    <button id="disconnectBtn" disabled>Disconnect</button>

    <div id="status">Disconnected</div>

    <!-- 2. Debug Monitor -->
    <div style="margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ccc;">
        <strong>ðŸ“Š Live Debug Monitor</strong>
        <div style="display: flex; gap: 20px; margin-top: 5px;">
            <div>Speed Status: <span id="wpmStatus" style="font-weight: bold; color: blue;">-</span></div>
            <div style="flex: 1;">
                Active Dynamic Instruction:
                <div id="dynamicInstruction"
                    style="background: white; padding: 5px; font-size: 12px; height: 40px; overflow: auto; border: 1px dashed gray;">
                    (Waiting for update...)</div>
            </div>
        </div>
    </div>

    <div id="log"></div>

    <div style="margin: 20px; border: 1px solid #ddd; padding: 10px; border-radius: 8px;">
        <h3>Session Settings & Prompts</h3>

        <div>
            <label>Voice: </label>
            <select id="voiceSelect"
                class="bg-gray-700 text-white rounded p-2 text-sm border border-gray-600 focus:border-blue-500 focus:outline-none">
                <option value="alloy">Alloy (Default)</option>
                <option value="ash">Ash</option>
                <option value="ballad">Ballad</option>
                <option value="coral">Coral</option>
                <option value="echo">Echo</option>
                <option value="sage">Sage</option>
                <option value="shimmer">Shimmer</option>
                <option value="verse">Verse</option>
            </select>
        </div>

        <!-- 3-Layer Prompt UI -->
        <div class="mt-4" style="display: flex; gap: 10px; margin-top: 15px;">
            <div style="flex: 1;">
                <label>1. Base System Prompt (Read-only)</label>
                <textarea id="basePromptInput" readonly
                    style="width: 100%; height: 200px; background-color: #eee; color: #555; box-sizing: border-box;"></textarea>
            </div>
            <div style="flex: 1;">
                <label>2. User Custom Instructions (Editable)</label>
                <textarea id="userPromptInput" style="width: 100%; height: 200px; box-sizing: border-box;"
                    placeholder="e.g. Speak Korean only, Be sarcastic..."></textarea>
            </div>
        </div>

        <button id="updateSettingsBtn" style="background-color: #4CAF50; color: white; margin-top: 10px;">Update
            Settings (Apply User Prompt)</button>
    </div>

    <script>
        let ws;
        let audioContext;
        let mediaStream;
        let workletNode;
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');

        // Settings UI
        const voiceSelect = document.getElementById('voiceSelect');
        const basePromptInput = document.getElementById('basePromptInput');
        const userPromptInput = document.getElementById('userPromptInput');
        const updateSettingsBtn = document.getElementById('updateSettingsBtn');
        const sessionIdInput = document.getElementById('sessionIdInput');

        // Debug UI
        const wpmStatusSpan = document.getElementById('wpmStatus');
        const dynamicInstructionDiv = document.getElementById('dynamicInstruction');

        function log(msg) {
            logDiv.innerHTML += `<div>${msg}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function generateUUID() {
            const uuid = crypto.randomUUID();
            sessionIdInput.value = uuid;
        }

        // Update Settings Button Logic
        updateSettingsBtn.onclick = () => {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert("WebSocket is not connected!");
                return;
            }

            const newSettings = {
                type: "session.update",
                config: {
                    voice: voiceSelect.value,
                    instructions: userPromptInput.value // Only send User layer
                }
            };

            ws.send(JSON.stringify(newSettings));
            log(">> Sent Settings Update Request (User Prompt)");
        };

        connectBtn.onclick = async () => {
            let sessionId = sessionIdInput.value.trim();
            statusDiv.textContent = "Connecting...";

            // Build WS URL
            let url = "ws://localhost:8002/ws/chat";
            if (sessionId) {
                url += `?session_id=${sessionId}`;
            }

            ws = new WebSocket(url);

            ws.onopen = async () => {
                statusDiv.textContent = `Connected (Session: ${sessionId || 'New'})`;
                log(`WS Connected to ${url}`);
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                await startAudio();
            };

            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);

                // [Debug Monitor]
                if (data.type === "debug.state") {
                    wpmStatusSpan.textContent = data.wpm_status;
                    dynamicInstructionDiv.textContent = data.dynamic_instruction || "(None)";
                    dynamicInstructionDiv.style.backgroundColor = "#e8f5e9"; // blink effect
                    setTimeout(() => dynamicInstructionDiv.style.backgroundColor = "white", 300);
                    return;
                }

                if (data.type === "audio.delta") {
                    playPcm16(data.delta);
                } else if (data.type === "speech.started") {
                    log("User started speaking... (Interruption detected)");
                    clearScheduledAudio();
                } else if (data.type === "transcript.done") {
                    // Standard transcript (fallback or if tool not used)
                    log(`AI: ${data.transcript}`);
                } else if (data.type === "bilingual.transcript") {
                    // Bilingual Transcript Display
                    const html = `
                        <div style="background-color: #e3f2fd; padding: 10px; border-radius: 5px; margin: 5px 0;">
                            <div style="font-weight: bold; color: #1565c0;">ðŸ‡ºðŸ‡¸ ${data.english_script}</div>
                            <div style="color: #555; margin-top: 4px;">ðŸ‡°ðŸ‡· ${data.korean_translation}</div>
                        </div>
                    `;
                    logDiv.innerHTML += html;
                    logDiv.scrollTop = logDiv.scrollHeight;
                } else if (data.type === "user.transcript") {
                    log(`You: ${data.transcript}`);
                }
            };

            ws.onclose = () => {
                statusDiv.textContent = "Disconnected";
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                stopAudio();
                log("WS Closed");
            };
        };

        disconnectBtn.onclick = () => {
            if (ws) ws.close();
        };

        async function startAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 24000,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // If WS closed while getting permission, stop immediately
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    console.warn("WS closed during audio init. Aborting.");
                    if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
                    if (audioContext && audioContext.state !== 'closed') audioContext.close();
                    return;
                }

                if (audioContext.state === 'closed') {
                    console.warn("AudioContext is closed. Aborting.");
                    return;
                }

                log("Microphone Access Granted");

                // Initialize AudioWorklet for raw PCM processing
                await audioContext.audioWorklet.addModule("data:text/javascript;base64," + btoa(`
                    class Processor extends AudioWorkletProcessor {
                        process(inputs, outputs, parameters) {
                            const input = inputs[0];
                            if (input.length > 0) {
                                const float32Data = input[0];
                                const int16Data = new Int16Array(float32Data.length);
                                for (let i = 0; i < float32Data.length; i++) {
                                    // Float32 (-1.0 to 1.0) -> Int16 (-32768 to 32767)
                                    let s = Math.max(-1, Math.min(1, float32Data[i]));
                                    int16Data[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                                }
                                this.port.postMessage(int16Data.buffer);
                            }
                            return true;
                        }
                    }
                    registerProcessor('recorder-processor', Processor);
                `));

                const source = audioContext.createMediaStreamSource(mediaStream);
                workletNode = new AudioWorkletNode(audioContext, 'recorder-processor');

                workletNode.port.onmessage = (event) => {
                    const arrayBuffer = event.data;
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        const base64Audio = arrayBufferToBase64(arrayBuffer);
                        ws.send(JSON.stringify({
                            type: "input_audio_buffer.append",
                            audio: base64Audio
                        }));
                    }
                };

                source.connect(workletNode);
                workletNode.connect(audioContext.destination);
                workletNode.disconnect(); // Prevent feedback

            } catch (e) {
                log(`Error starting audio: ${e.message}`);
            }
        }

        function stopAudio() {
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (audioContext) audioContext.close();
        }

        let nextStartTime = 0;
        let scheduledAudioSources = [];

        function playPcm16(base64Data) {
            if (!audioContext) return;

            const binaryString = atob(base64Data);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            const int16Data = new Int16Array(bytes.buffer);
            const float32Data = new Float32Array(int16Data.length);

            for (let i = 0; i < int16Data.length; i++) {
                float32Data[i] = int16Data[i] / 32768.0;
            }

            const buffer = audioContext.createBuffer(1, float32Data.length, 24000);
            buffer.getChannelData(0).set(float32Data);

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);

            const currentTime = audioContext.currentTime;
            if (nextStartTime < currentTime) {
                nextStartTime = currentTime;
            }

            source.start(nextStartTime);
            scheduledAudioSources.push(source);
            source.onended = () => {
                const index = scheduledAudioSources.indexOf(source);
                if (index > -1) scheduledAudioSources.splice(index, 1);
            };

            nextStartTime += buffer.duration;
        }

        function clearScheduledAudio() {
            scheduledAudioSources.forEach(source => {
                try { source.stop(); } catch (e) { }
            });
            scheduledAudioSources = [];
            if (audioContext) {
                nextStartTime = audioContext.currentTime;
            }
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        async function loadPrompt() {
            try {
                const response = await fetch('/prompt');
                const data = await response.json();
                if (data.prompt) {
                    basePromptInput.value = data.prompt; // Show Read-only Base
                }
            } catch (e) {
                console.error("Failed to load prompt:", e);
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            loadPrompt();
        });
    </script>
</body>

</html>